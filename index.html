<!doctype html>
  <link rel="stylesheet" href="style.css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="minimal-ui, width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <body>
    <div id="root"></div>
    <div id="export-image"></div>
    <script src="elm.js"></script>
    <!-- <script src="dist/goat-app_v1-0-0-rc.min.js"></script> -->
    <script src="https://assets.zendesk.com/apps/sdk/2.0/zaf_sdk.js"></script>
    <script>
      var isMac = navigator.userAgent.indexOf('Mac OS X') != -1
      var app = Elm.Main.embed(document.getElementById("root"), { isMac: isMac });
      var savedImage
      app.ports.exportToImage.subscribe(function(image) {
        savedImage = image;
        window.requestAnimationFrame(exportImage)
      })

      app.ports.listenForUpload.subscribe(function(className) {
        var target = document.querySelector('.' + className);
        target.addEventListener("dragover", function(e) { e.preventDefault(); });
        target.addEventListener("drop", function(e) {
        	  e.preventDefault()
        	  loadImage(e.dataTransfer.files[0])
        }, true);
      })

      function loadImage(src) {
        if (!src.type.match(/image.*/)) {
          return
        }
        var reader = new FileReader();
        reader.onload = function(e) {
          const contentType = 'image/png';
          const blob = b64toBlob(e.target.result.replace('data:image/png;base64,', ''), contentType);
          var editImageBlobUrl = URL.createObjectURL(blob);
          var newImg = new Image()
          newImg.crossOrigin = 'anonymous'
          newImg.onload = function() {
            app.ports.newImage.send({
              url: editImageBlobUrl,
              width: this.naturalWidth,
              height: this.naturalHeight,
              originalWidth: this.naturalWidth,
              originalHeight: this.naturalHeight
            })
          }
          newImg.src = editImageBlobUrl
        }
        reader.readAsDataURL(src)
      }

      function getImages(html) {
        const div = document.createElement('div')
        div.innerHTML = html
        const images = div.querySelectorAll('img')
        return Array.prototype.map.call(images, toImageObject)
      }

      function toImageObject(image) {
        const originalWidth = parseFloat(image.getAttribute('data-original-width'));
        const originalHeight = parseFloat(image.getAttribute('data-original-height'));
        const width = parseFloat(image.style.width.replace('px', ''));
        const height = width / (originalWidth / originalHeight);
        return {
          url: image.src,
          originalWidth: originalWidth,
          originalHeight: originalHeight,
          width: width,
          height: height
        }
      }

      function b64toBlob(b64Data, contentType='', sliceSize=512) {
        const byteCharacters = atob(b64Data);
        const byteArrays = [];
        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
          const slice = byteCharacters.slice(offset, offset + sliceSize);
          const byteNumbers = new Array(slice.length);
          for (let i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          byteArrays.push(byteArray);
        }
        const blob = new Blob(byteArrays, {type: contentType});
        return blob;
      }

      function autoScale(canvas) {
        // adapted from https://www.html5rocks.com/en/tutorials/canvas/hidpi/
        var context = canvas.getContext('2d');
        var devicePixelRatio = window.devicePixelRatio || 1;
        var backingStoreRatio = context.webkitBackingStorePixelRatio ||
                              context.mozBackingStorePixelRatio ||
                              context.msBackingStorePixelRatio ||
                              context.oBackingStorePixelRatio ||
                              context.backingStorePixelRatio || 1;

        var ratio = devicePixelRatio / backingStoreRatio;

        if (devicePixelRatio !== backingStoreRatio) {
            var oldWidth = canvas.width;
            var oldHeight = canvas.height;

            canvas.width = oldWidth * ratio;
            canvas.height = oldHeight * ratio;

            canvas.style.width = oldWidth + 'px';
            canvas.style.height = oldHeight + 'px';

            context.scale(ratio, ratio);
        }
      }

      function exportImage() {
        var image = savedImage
        var canvas = document.createElement('canvas')
        canvas.crossOrigin='anonymous'
        canvas.width = image.width
        canvas.height = image.height
        autoScale(canvas)
        var ctx = canvas.getContext('2d')
        var data = document.getElementById('drawing').outerHTML
        var DOMURL = window.URL || window.webkitURL || window;
        var drawingImg = new Image()
        drawingImg.crossOrigin = 'anonymous'
        var svg = new Blob([data], {type: 'image/svg+xml'});
        var url = DOMURL.createObjectURL(svg);
        drawingImg.onload = function() {
          ctx.drawImage(document.querySelector('.image-to-annotate'), 0, 0, image.originalWidth, image.originalHeight, 0, 0, image.width, Math.round(image.height))
          ctx.drawImage(drawingImg, 0, 0, image.width, Math.round(image.height));
          DOMURL.revokeObjectURL(url);
          canvas.toBlob(blob => {
            var exportImage = new Image()
            exportImage.crossOrigin = 'anonymous'
            exportImage.id = 'export-image'
            exportImage.src = DOMURL.createObjectURL(blob)
            exportImage.width = image.width
            exportImage.height = image.height
            document.body.replaceChild(exportImage, document.getElementById('export-image'))
          })
        }
        drawingImg.src = url
      };

      const client = window.ZAFClient ? ZAFClient.init() : null;
      if (client) {
        client.invoke('resize', { height: 320, width: 1000})
        client.on('pane.activated', readInImages)

        function readInImages(event) {
          client.get('ticket.comment').then(zaf => {
            const div = document.createElement('div')
            const comment = zaf['ticket.comment'].text
            div.innerHTML = comment
            const images = div.querySelectorAll('img');
            const imageObjects = Array.prototype.map.call(images, toImageObject)
            app.ports.setImages.send(imageObjects)
          })
        }
      }
    </script>
  </body>
