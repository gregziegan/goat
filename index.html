<!doctype html>
  <link rel="stylesheet" href="style.css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="minimal-ui, width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <body>
    <div id="root"></div>
    <div id="export-image"></div>
    <script src="elm.js"></script>
    <script src="dist/goat-app_v1-0-0-rc.min.js"></script>
    <script src="https://assets.zendesk.com/apps/sdk/2.0/zaf_sdk.js"></script>
    <script>
     // polyfills
     if (!HTMLCanvasElement.prototype.toBlob) {
      Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
       value: function (callback, type, quality) {

         var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),
             len = binStr.length,
             arr = new Uint8Array(len);

         for (var i = 0; i < len; i++ ) {
          arr[i] = binStr.charCodeAt(i);
         }

         callback( new Blob( [arr], {type: type || 'image/png'} ) );
       }
      });
     }
    </script>
    <script>
      // flags
      var isMac = navigator.userAgent.indexOf('Mac OS X') != -1;
      var client = window.ZAFClient ? ZAFClient.init() : null;
      var isInZendeskAppContext = !!client;


      var app = Elm.Main.embed(document.getElementById("root"), { isMac: isMac, inZendesk : isInZendeskAppContext });
      var savedImage;

      // ports
      app.ports.exportToImage.subscribe(function (image) {
        savedImage = image;
        window.requestAnimationFrame(exportImage);
      });

      app.ports.listenForUpload.subscribe(function () {
        var target = document.querySelector('.droparea');
        target.addEventListener("dragover", function (e) {
          e.preventDefault();
        });
        target.addEventListener("drop", function (e) {
          e.preventDefault();
          var file = e.dataTransfer.files[0]
          if (!file.type.match(/image.*/)) {
            return;
          }
          loadImage(file)
            .then(function(loadedImage) {
              app.ports.newImage.send(loadedImage);
            })
        }, true);
      });

      app.ports.requestImages.subscribe(function () {
        if (isInZendeskAppContext) {
          readInImagesFromZendesk();
        } else {
          var goats = [
            { id: '0', url: 'images/goat.jpg', width: 235, height: 276, originalWidth: 639, originalHeight: 751},
            { id: '0', url: 'images/goat2.jpg', width: 235, height: 276, originalWidth: 639, originalHeight: 751}
          ];
          readInImages(goats).then(function (localImages) {
            app.ports.setImages.send(localImages);
          });
        }
      });

      // zendesk listeners
      if (isInZendeskAppContext) {
        client.invoke('resize', { height: 320, width: 800 });
        client.on('pane.activated', readInImagesFromZendesk);
        client.on('pane.deactivated', function() {
          app.ports.reset.send(null);
        })
      }

      var DOMURL = window.URL || window.webkitURL || window;

      // helper functions
      function blobImageTo64(src) {
        return new Promise(function(resolve) {
          var reader = new FileReader();
          reader.onload = resolve
          reader.readAsDataURL(src);
        })
      }

      function createImage(img, imageUrl) {
        return new Promise(function(resolve) {
          img.crossOrigin = 'anonymous';
          img.onload = function() {
            resolve(this)
          }
          img.src = imageUrl;
        });
      }

      function loadImage(src) {
        return blobImageTo64(src)
          .then(function(e) {
            var contentType = 'image/png';
            var blob = b64toBlob(e.target.result.replace('data:image/png;base64,', ''), contentType);
            var imageUrl = DOMURL.createObjectURL(blob);
            var newImage = new Image();
            return createImage(newImage, imageUrl)
          }).then(function(img) {
            return {
              id: '0',
              url: img.src,
              width: img.naturalWidth,
              height: img.naturalHeight,
              originalWidth: img.naturalWidth,
              originalHeight: img.naturalHeight
            }
          });
      }

      function b64toBlob(b64Data) {
        var contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var sliceSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 512;

        var byteCharacters = atob(b64Data);
        var byteArrays = [];
        for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
          var slice = byteCharacters.slice(offset, offset + sliceSize);
          var byteNumbers = new Array(slice.length);
          for (var i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
          }
          var byteArray = new Uint8Array(byteNumbers);
          byteArrays.push(byteArray);
        }
        return new Blob(byteArrays, { type: contentType });
      }

      function toImageObject(image) {
        var id = image.getAttribute('data-imageuploadid');
        var originalWidth = parseFloat(image.getAttribute('data-original-width'));
        var originalHeight = parseFloat(image.getAttribute('data-original-height'));
        var width = parseFloat(image.style.width.replace('px', ''));
        var height = width / (originalWidth / originalHeight);
        return {
          id: id,
          url: image.src,
          originalWidth: originalWidth,
          originalHeight: originalHeight,
          width: width,
          height: height
        };
      }

      function toLocalImage(imageObject) {
        return new Promise(function (resolve) {
          var img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = function () {
            resolve({ img: img, imageObject: imageObject, status: 'ok' });
          };

          img.src = imageObject.url;
        });
      }

      function getImageUrl(img, imageObject) {
        return new Promise(function (resolve) {
          var canvas = document.createElement("canvas");
          canvas.width = img.width;
          canvas.height = img.height;

          var ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);

          var newImageObject = imageObject;
          newImageObject.url = canvas.toDataURL("image/png");
          resolve(newImageObject);
        });
      }

      function exportImage() {
        var svg = document.getElementById( "drawing" );
        var svgCopy = svg.cloneNode(true)
        encodeSvgBlobs(svgCopy)
          .then(exportBlob)
      }

      function fetchBlob(url) {
        return new Promise(function(resolve) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'blob';
          xhr.onload = function() {
            resolve(this)
          }
          xhr.send();
        });
      }

      function encodeSvgBlobs(svg) {
        var imageBlobUrl = svg.querySelector('image').getAttribute('xlink:href');

        return fetchBlob(imageBlobUrl)
          .then(function(xhrResponse) {
            if (xhrResponse.status == 200) {
              return blobImageTo64(xhrResponse.response)
                .then(function(e) {
                  var b64Url = e.target.result;
                  var images = svg.querySelectorAll('image')
                  images[0].setAttribute('xlink:href', b64Url);
                  images[1].setAttribute('xlink:href', b64Url);
                  return svg
                });
            }
          });
      }

      function exportBlob (svg) {
        var image = savedImage;
        var svgData = new XMLSerializer().serializeToString(svg);

        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        ctx.imageSmoothingEnabled = false;
        var newImage = document.createElement('img');
        newImage.width = image.width;
        newImage.height = image.height;

        createImage(newImage, "data:image/svg+xml;base64," + btoa( svgData ))
          .then(function() {
            canvas.width = image.width
            canvas.height = image.height
            ctx.drawImage( newImage, 0, 0, image.width, image.height);
            if (isInZendeskAppContext) {
              client.get('ticket.comment').then(function (zaf) {
                var div = document.createElement('div');
                var comment = zaf['ticket.comment'].text;
                div.innerHTML = comment;
                var selectionBox = div.querySelector('span.zd-editor--rich-text-comment--resize-box');
                var imageToReplace = div.querySelector('img[data-imageuploadid="' + image.id + '"]');
                if (selectionBox && imageToReplace) {
                  selectionBox.outerHTML = '';
                } else {
                  imageToReplace.outerHTML = '';
                }
                client.set('ticket.comment.text', div.innerHTML).then(function () {
                  client.invoke('ticket.editor.inlineImage', canvas.toDataURL('image/png'));
                  client.invoke('app.close');
                  app.ports.reset.send(null);
                });
              });
            } else {
              newImage.id = 'export-image';
              document.body.replaceChild(newImage, document.getElementById('export-image'));
            }
          });
      }

      function readInImagesFromZendesk() {
        client.get('ticket.comment').then(function (zaf) {
          var div = document.createElement('div');
          var comment = zaf['ticket.comment'].text;
          div.innerHTML = comment;
          var selectedImage = div.querySelector('span.zd-editor--rich-text-comment--resize-box img')
          if (selectedImage) {
            // readInImages([toImageObject(selectedImage)])
            //   .then(function (localImages) {
            //     app.ports.newImage.send(localImages[0]);
            //   });
            app.ports.setImages.send([selectedImage]);
          } else {
            var images = div.querySelectorAll('img');
            var imageObjects = Array.prototype.map.call(images, toImageObject);
            // readInImages(imageObjects).then(function (localImages) {
            //   app.ports.setImages.send(localImages);
            // });
            app.ports.setImages.send(imageObjects);
          }
        });
      }

      function readInImages(imageObjects) {
        return Promise.all(Array.prototype.map.call(imageObjects, toLocalImage)).then(function (allLocalImageData) {
          return Promise.all(Array.prototype.map.call(allLocalImageData, function (localData) {
            return getImageUrl(localData.img, localData.imageObject);
          }));
        })
      }
    </script>
  </body>
